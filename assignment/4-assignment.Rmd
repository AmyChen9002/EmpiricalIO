---
title: 'Assignment 4: Demand Function Estimation II'
author: "Kohei Kawaguchi"
date: "2019/1/29"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include = FALSE}
library(EmpiricalIO)
library(magrittr)
library(stargazer)
library(knitr)
library(foreach)
library(ggplot2)
library(latex2exp)
library(doParallel)
knitr::opts_chunk$set(echo = FALSE, fig.align = "center")
```

## Simulate data

We simulate data from a discrete choice model that is the same with in assignment 3 except for the existence of unobserved product-specific fixed effects. There are $T$ markets and each market has $N$ consumers. There are $J$ products and the indirect utility of consumer $i$ in market $t$ for product $j$ is:
$$
u_{itj} = \beta_{it}' x_j + \alpha_{it} p_{jt} + \xi_{jt} + \epsilon_{ijt},
$$
where $\epsilon_{ijt}$ is an i.i.d. type-I extreme random variable.  $x_j$ is $K$-dimensional observed characteristics of the product. $p_{jt}$ is the retail price of the product in the market. 

$\xi_{jt}$ is product-market specific fixed effect. $p_{jt}$ can be correlated with $\xi_{jt}$ but $x_{jt}$s are independent of $\xi_{jt}$. $j = 0$ is an outside option whose indirect utility is:
$$
u_{it0} = \epsilon_{i0t},
$$
where $\epsilon_{i0t}$ is an i.i.d. type-I extreme random variable. 

$\beta_{it}$ and $\alpha_{it}$ are different across consumers, and they are distributed as:
$$
\beta_{itk} = \beta_{0k} + \sigma_k \nu_{itk},
$$
$$
\alpha_{it} = - \exp(\mu + \omega \upsilon_{it}) = - \exp(\mu + \frac{\omega^2}{2}) + [- \exp(\mu + \omega \upsilon_{it}) + \exp(\mu + \frac{\omega^2}{2})] \equiv \alpha_0 + \tilde{\alpha}_{it},
$$
where $\nu_{itk}$ for $k = 1, \cdots, K$ and $\upsilon_{it}$ are i.i.d. standard normal random variables. $\alpha_0$ is the mean of $\alpha_i$ and $\tilde{\alpha}_i$ is the deviation from the mean.

Given a choice set in the market, $\mathcal{J}_t \cup \{0\}$, a consumer chooses the alternative that maximizes her utility:
$$
q_{ijt} = 1\{u_{ijt} = \max_{k \in \mathcal{J}_t \cup \{0\}} u_{ikt}\}.
$$
The choice probability of product $j$ for consumer $i$ in market $t$ is:
$$
\sigma_{jt}(p_t, x_t, \xi_t) = \mathbb{P}\{u_{ijt} = \max_{k \in \mathcal{J}_t \cup \{0\}} u_{ikt}\}.
$$

Suppose that we only observe the share data:
$$
s_{jt} = \frac{1}{N} \sum_{i = 1}^N q_{ijt},
$$
along with the product-market characteristics $x_{jt}$ and the retail prices $p_{jt}$ for $j \in \mathcal{J}_t \cup \{0\}$ for $t = 1, \cdots, T$. We do not observe the choice data $q_{ijt}$ nor shocks $\xi_{jt}, \nu_{it}, \upsilon_{it}, \epsilon_{ijt}$.

We draw $\xi_{jt}$ from i.i.d. normal distribution with mean 0 and standard deviation $\sigma_{\xi}$.

1. Set the seed, constants, and parameters of interest as follows.

```{r, echo = TRUE}
# set the seed
set.seed(1)
# number of products
J <- 10
# dimension of product characteristics including the intercept
K <- 3
# number of markets
T <- 100
# number of consumers per market
N <- 500
# number of Monte Carlo
L <- 500
```

```{r, echo = TRUE}
# set parameters of interests
beta <- rnorm(K); 
beta[1] <- 4
beta
sigma <- abs(rnorm(K)); sigma
mu <- 0.5
omega <- 1
```

Generate the covariates as follows.

The product-market characteristics:
$$
x_{j1} = 1, x_{jk} \sim N(0, \sigma_x), k = 2, \cdots, K,
$$
where $\sigma_x$ is referred to as `sd_x` in the code.

The product-market-specific unobserved fixed effect:
$$
\xi_{jt} \sim N(0, \sigma_\xi),
$$
where $\sigma_xi$ is referred to as `sd_xi` in the code.

The marginal cost of product $j$ in market $t$:
$$
c_{jt} \sim \text{logNormal}(0, \sigma_c),
$$
where $\sigma_c$ is referred to as `sd_c` in the code.


The retail price:
$$
p_{jt} - c_{jt} \sim \text{logNorm}(\gamma \xi_{jt}, \sigma_p),
$$
where $\gamma$ is referred to as `price_xi` and $\sigma_p$ as `sd_p` in the code. This price is not the equilibrium price. We will revisit this point in a subsequent assignment.

The value of the auxiliary parameters are set as follows:

```{r, echo = TRUE}
# set auxiliary parameters
price_xi <- 1
prop_jt <- 0.6
sd_x <- 0.5
sd_xi <- 0.5
sd_c <- 0.05
sd_p <- 0.05
```

2. `X` is the data frame such that a row contains the characteristics vector $x_{j}$ of a product and columns are product index and observed product characteristics. The dimension of the characteristics $K$ is specified above. Add the row of the outside option whose index is $0$ and all the characteristics are zero.


```{r}
# make product characteristics data
X <- matrix(sd_x * rnorm(J * (K - 1)), nrow = J)
X <- cbind(rep(1, J), X)
colnames(X) <- paste("x", 1:K, sep = "_")
X <- data.frame(j = 1:J, X) %>%
  tibble::as_tibble()
# add outside option
X <- rbind(
  rep(0, dim(X)[2]),
  X
) 
```

```{r, echo = TRUE}
X
```

3. `M` is the data frame such that a row contains the price $\xi_{jt}$, marginal cost $c_{jt}$, and price $p_{jt}$. After generating the variables, drop `1 - prop_jt` products from each market using `dplyr::sample_frac` function. The variation in the available products is important for the identification of the distribution of consumer-level unobserved heterogeneity. Add the row of the outside option to each market whose index is $0$ and all the variables take value zero.

```{r}
# make market-product data
M <- expand.grid(j = 1:J, t = 1:T) %>%
  tibble::as_tibble() %>%
  dplyr::mutate(
    xi = sd_xi * rnorm(J*T),
    c = exp(sd_c * rnorm(J*T)),
    p = exp(price_xi * xi + sd_p * rnorm(J*T)) + c
  ) 
M <- M %>%
  dplyr::group_by(t) %>%
  dplyr::sample_frac(prop_jt) %>%
  dplyr::ungroup()
# add outside option
outside <- data.frame(j = 0, t = 1:T, xi = 0, c = 0, p = 0)
M <- rbind(
  M,
  outside
) %>%
  dplyr::arrange(t, j)
```

```{r, echo = TRUE}
M
```

4. Generate the consumer-level heterogeneity. `V` is the data frame such that a row contains the vector of shocks to consumer-level heterogeneity, $(\nu_{i}', \upsilon_i)$. They are all i.i.d. standard normal random variables. 


```{r}
# make consumer-market data
V <- matrix(rnorm(N * T * (K + 1)), nrow = N * T) 
colnames(V) <- c(paste("v_x", 1:K, sep = "_"), "v_p")
V <- data.frame(
  expand.grid(i = 1:N, t = 1:T),
  V
) %>%
  tibble::as_tibble()
```

```{r, echo = TRUE}
V
```

5. Join `X`, `M`, `V` using `dplyr::left_join` and name it `df`. `df` is the data frame such that a row contains variables for a consumer about a product that is available in a market.


```{r}
# make choice data
df <- expand.grid(t = 1:T, i = 1:N, j = 0:J) %>%
  tibble::as_tibble() %>%
  dplyr::left_join(V, by = c("i", "t")) %>%
  dplyr::left_join(X, by = c("j")) %>%
  dplyr::left_join(M, by = c("j", "t")) %>%
  dplyr::filter(!is.na(p)) %>%
  dplyr::arrange(t, i, j)
```

```{r, echo = TRUE}
df
```

6. Draw a vector of preference shocks `e` whose length is the same as the number of rows of `df`.

```{r}
# draw idiosyncratic shocks
e <- evd::rgev(dim(df)[1])
```

```{r, echo = TRUE}
head(e)
```

7. Write a function `compute_indirect_utility(df, beta, sigma, mu, omega)` that returns a vector whose element is the mean indirect utility of a product for a consumer in a market. The output should have the same length with $e$.

```{r, echo = TRUE}
# compute indirect utility
u <- 
  compute_indirect_utility(
    df, beta, sigma, 
           mu, omega)
head(u)
```

8. Write a function `compute_choice(X, M, V, e, beta, sigma, mu, omega)` that first construct `df` from `X`, `M`, `V`, second call `compute_indirect_utility` to obtain the vector of mean indirect utilities `u`, third compute the choice vector `q` based on the vector of mean indirect utilities and `e`, and finally return the data frame to which `u` and `q` are added as columns. 

```{r, echo = TRUE}
# compute choice
df_choice <- 
  compute_choice(X, M, V, e, beta, sigma, 
                 mu, omega)
df_choice
summary(df_choice)
```

9. Write a function `compute_share(X, M, V, e, beta, sigma, mu, omega)` that first construct `df` from `X`, `M`, `V`, second call `compute_choice` to obtain a data frame with `u` and `q`, third compute the share of each product at each market `s` and the log difference in the share from the outside option, $\ln(s_{jt}/s_{0t})$, denoted by `y`, and finally return the data frame that is summarized at the product-market level, dropped consumer-level variables, and added `s` and `y`.


```{r share, echo = TRUE}
# compute share
df_share <-
  compute_share(X, M, V, e, beta, sigma, 
                mu, omega)
df_share
summary(df_share)
```

## Estimate the parameters

1. First draw Monte Carlo consumer-level heterogeneity `V_mcmc` and Monte Carlo preference shocks `e_mcmc`. The number of simulations is `L`. This does not have to be the same with the actual number of consumers `N`. 

```{r}
# mixed logit estimation
## draw mcmc V
V_mcmc <- matrix(rnorm(L*T*(K + 1)), nrow = L*T) 
colnames(V_mcmc) <- c(paste("v_x", 1:K, sep = "_"), "v_p")
V_mcmc <- data.frame(
  expand.grid(i = 1:L, t = 1:T),
  V_mcmc
) %>%
  tibble::as_tibble() 
```

```{r, echo = TRUE}
V_mcmc
```

```{r}
## draw mcmc e
df_mcmc <- expand.grid(t = 1:T, i = 1:L, j = 0:J) %>%
  tibble::as_tibble() %>%
  dplyr::left_join(V_mcmc, by = c("i", "t")) %>%
  dplyr::left_join(X, by = c("j")) %>%
  dplyr::left_join(M, by = c("j", "t")) %>%
  dplyr::filter(!is.na(p)) %>%
  dplyr::arrange(t, i, j)
# draw idiosyncratic shocks
e_mcmc <- evd::rgev(dim(df_mcmc)[1])
```
```{r, echo = TRUE}
head(e_mcmc)
```

2. Vectorize the parameters to a vector `theta` because `optim` requires the maximiand to be a vector.

```{r, echo = TRUE}
# set parameters
theta <- c(beta, sigma, mu, omega)
theta
```

3. Estimate the parameters assuming there is no product-specific unobserved fixed effects $\xi_{jt}$, i.e., using the functions in assignment 3. To do so, first modify `M` to `M_no` in which `xi` is replaced with 0 and estimate the model with `M_no`. Otherwise, your `df_share` will compute the share with the true `xi`.

```{r, echo = TRUE}
M_no <- M %>%
  dplyr::mutate(xi = 0)
```

```{r, eval = FALSE}
# find NLLS estimator
result_NLLS <- 
  optim(par = theta, fn = NLLS_objective_A3,
        method = "Nelder-Mead",
        df_share = df_share, 
        X = X, 
        M = M_no, 
        V_mcmc = V_mcmc, 
        e_mcmc = e_mcmc)
save(result_NLLS, file = "data/A4_result_NLLS.RData")
```


```{r}
result_NLLS <- get(load(file = "data/A4_result_NLLS.RData"))
result_NLLS
result <- data.frame(true = theta, estimates = result_NLLS$par)
result
```

Next, we estimate the model allowing for the product-market-specific unobserved fixed effect $\xi_{jt}$ using the BLP algorithm. To do so, we slightly modify the `compute_indirect_utility`, `compute_choice`, `compute_share` functions so that they receive $\delta_{jt}$ to compute the indirect utilities, choices, and shares. Be careful that the treatment of $\alpha_i$ is slightly different from the lecture note, because we assumed that $\alpha_i$s are log-normal random variables.

4. Compute and print out $\delta_{jt}$ at the true parameters, i.e.:
$$
\delta_{jt} = \beta_0' x_j + \alpha_0' p_{jt} + \xi_{jt}.
$$
```{r delta}
XX <- as.matrix(dplyr::select(df, dplyr::starts_with("x_")))
pp <- as.matrix(dplyr::select(df, p)) 
alpha <- - exp(mu + omega^2/2)
delta <- XX %*% as.matrix(beta) + pp * alpha
colnames(delta) <- "delta"
head(delta)
```


5. Write a function `compute_indirect_utility_delta(df, delta, sigma, mu, omega)` that returns a vector whose element is the mean indirect utility of a product for a consumer in a market. The output should have the same length with $e$. Print out the output with $\delta_{jt}$ evaluated at the true parameters.
```{r, echo = TRUE}
# compute indirect utility from delta
u <-
  compute_indirect_utility_delta(df, delta, sigma,
                                 mu, omega)
head(u)
```


6. Write a function `compute_choice_delta(X, M, V, e, delta, sigma, mu, omega)` that first construct `df` from `X`, `M`, `V`, second call `compute_indirect_utility_delta` to obtain the vector of mean indirect utilities `u`, third compute the choice vector `q` based on the vector of mean indirect utilities and `e`, and finally return the data frame to which `u` and `q` are added as columns. 


```{r, echo = TRUE}
# compute choice
df_choice <- 
  compute_choice_delta(X, M, V, e, delta, sigma, mu, omega)
df_choice
```


7. Write a function `compute_share_delta(X, M, V, e, delta, sigma, mu, omega)` that first construct `df` from `X`, `M`, `V`, second call `compute_choice_delta` to obtain a data frame with `u` and `q`, third compute the share of each product at each market `s` and the log difference in the share from the outside option, $\ln(s_{jt}/s_{0t})$, denoted by `y`, and finally return the data frame that is summarized at the product-market level, dropped consumer-level variables, and added `s` and `y`.

```{r, echo = TRUE}
# compute share
df_share <-
  compute_share_delta(X, M, V, e, delta, sigma, mu, omega) 
df_share
summary(df_share)
```


8. Extract the share data from `df_share` and name it `s`.

```{r, echo = TRUE}
s <- df_share %>%
  dplyr::select(t, j, s)
s
```


9. Write a function `solve_delta(s, X, M, V, e, delta, sigma, mu, omega)` that finds $\delta_{jt}$ that equates the actua share and the predicted share by the fixed-point algorithm. Set the stopping criterion at $\max_{jt}|\delta_{jt}^{(r + 1)} - \delta_{jt}^{(r)}| < 10^{-10}$. Start the algorithm with the true $\delta_{jt}$ and check if the algorithm returns (almost) the same $\delta_{jt}$.

```{r, echo = TRUE}
delta_new <-
  solve_delta(s, X, M, V, e, delta, sigma, mu, omega)
head(delta_new)
summary(delta_new - delta)
```

10. Construct the excluded instrumental variable as follows.

```{r}
df
```


